namespace CustomSearchesWorkerLibrary.RScript
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Data.Common;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using BaseWorkerLibrary;
    using CustomSearchesEFLibrary.CustomSearches;
    using CustomSearchesEFLibrary.CustomSearches.Model;
    using CustomSearchesEFLibrary.WorkerJob.Model;
    using CustomSearchesServicesLibrary.CustomSearches;
    using CustomSearchesServicesLibrary.CustomSearches.Enumeration;
    using CustomSearchesServicesLibrary.CustomSearches.Executor;
    using CustomSearchesServicesLibrary.CustomSearches.Model;
    using CustomSearchesServicesLibrary.CustomSearches.Model.RScript;
    using CustomSearchesServicesLibrary.CustomSearches.Services.Datasets;
    using CustomSearchesWorkerLibrary.Enumeration;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Logging;
    using Microsoft.WindowsAzure.Storage.Blob;
    using Newtonsoft.Json;
    using PTASServicesCommon.CloudStorage;
    using PTASServicesCommon.DependencyInjection;

    /// <summary>
    /// R Scripting worker class
    /// </summary>
    public class RScriptProcessor : WorkerJobProcessor
    {
        /// <summary>
        /// Semaphore used to disallow the execution of two RScipt at the same time. (RDotNet is not thread safe).
        /// </summary>
        private static SemaphoreSlim semaphoreSlim = new SemaphoreSlim(1, 1);

        /// <summary>
        /// The default data CSV file name
        /// </summary>
        private const string DataCsvFileName = "dataset.csv";

        /// <summary>
        /// The default outupt CSV file name
        /// </summary>
        private const string OutputCsvFileName = "output.csv";

        /// <summary>
        /// The default json parameters file name
        /// </summary>
        private const string JsonParametersFileName = "parameters.json";

        /// <summary>
        /// RScript blob container name.
        /// </summary>
        private const string RScriptBlobContainerName= "rscript";

        /// <summary>
        /// Folder name for results in blob container.
        /// </summary>
        private const string BlobResultsFolderName = "results";

        /// <summary>
        /// Folder name for results in blob container.
        /// </summary>
        private const string JSonResultsFileName = "results.json";

        /// <summary>
        /// The test section marker
        /// </summary>
        private const string TestSectionMarker = "# Test Code Section ---------------------------------";

        /// <summary>
        /// The server section marker
        /// </summary>
        private const string ServerSectionMarker = "# Server Code Section ---------------------------------";

        /// <summary>
        /// The libraries path
        /// </summary>
        private string librariesPath;

        /// <summary>
        /// The execution path
        /// </summary>
        private string executionPath;

        /// <summary>
        /// The SQL Server db context factory.
        /// </summary>
        private readonly IFactory<CustomSearchesDbContext> dbContextFactory;

        /// <summary>
        /// The cloud storage provider.
        /// </summary>
        private readonly ICloudStorageProvider cloudStorageProvider;

        /// <summary>
        /// Keeps track of files not generated by the RScript.
        /// </summary>
        private HashSet<string> trackedFiles = new HashSet<string>();

        /// <summary>
        /// Gets the type of the processor.
        /// </summary>
        public override string ProcessorType 
        { 
            get
            {
                return nameof(CustomSearchesJobTypes.RScriptJobType);
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RScriptProcessor" /> class.
        /// </summary>
        /// <param name="cloudStorageProvider">The cloud storage provider.</param>
        /// <param name="dbContextFactory">The data database context factory.</param>
        /// <param name="logger">The logger.</param>
        /// <param name="librariesPath">The libraries path.</param>
        /// <param name="executionPath">The execution path.</param>
        /// <exception cref="ArgumentNullException">When the cloudStorageProvider/logger/librariesPath/executionFolder parameter is null.</exception>
        public RScriptProcessor(
            ICloudStorageProvider cloudStorageProvider,
            IFactory<CustomSearchesDbContext> dbContextFactory,
            ILogger logger,
            string librariesPath,
            string executionPath) : base(logger)
        {
            if (string.IsNullOrWhiteSpace(librariesPath))
            {
                throw new ArgumentNullException(nameof(librariesPath));
            }

            if (string.IsNullOrWhiteSpace(executionPath))
            {
                throw new ArgumentNullException(nameof(executionPath));
            }

            if (cloudStorageProvider == null)
            {
                throw new System.ArgumentNullException(nameof(cloudStorageProvider));
            }

            if (dbContextFactory == null)
            {
                throw new System.ArgumentNullException(nameof(dbContextFactory));
            }

            if (dbContextFactory == null)
            {
                throw new System.ArgumentNullException(nameof(dbContextFactory));
            }

            this.dbContextFactory = dbContextFactory;
            this.librariesPath = librariesPath;
            this.executionPath = Path.Combine(executionPath, Guid.NewGuid().ToString().Replace("-", "_"));
            this.cloudStorageProvider = cloudStorageProvider;
        }

        /// <summary>
        /// Processes the available job.
        /// </summary>
        /// <param name="workerJob"></param>
        /// <returns>True if the job completed successfully</returns>
        public override async Task<bool> ProcessAvailableJob(WorkerJobQueue workerJob)
        {
            try
            {
                var payload = JsonConvert.DeserializeObject<RScriptJobPayload>(workerJob.JobPayload);
                using (CustomSearchesDbContext dbContext = this.dbContextFactory.Create())
                {
                    CloudBlobContainer blobContainer = await this.cloudStorageProvider.GetCloudBlobContainer(RScriptProcessor.RScriptBlobContainerName, this.ServiceContext.AppCredential);

                    DatasetPostProcess postProcess =
                        await (from dp in dbContext.DatasetPostProcess where dp.DatasetPostProcessId == payload.DatasetPostProcessId select dp)
                        .Include(dp => dp.Dataset)
                        .FirstOrDefaultAsync();

                    if (postProcess == null)
                    {
                        // Throw Exception
                    }

                    this.LogMessage(workerJob, "Initializing execution folder...");
                    var rScriptModel = await this.InitializeExecutionFolder(dbContext, blobContainer, workerJob, payload);

                    try
                    {
                        this.LogMessage(workerJob, "Generating JSON parameters...");
                        await this.GenerateJsonParametersFile(postProcess, rScriptModel, dbContext);

                        this.LogMessage(workerJob, "Generating Dataset CSV...");
                        await this.GenerateDatasetCsv(postProcess.Dataset, postProcess, workerJob);

                        this.LogMessage(workerJob, "Executing R script...");
                        await this.ExecuteRScript(rScriptModel);

                        this.LogMessage(workerJob, "Uploading result files...");
                        await this.ProcessGeneratedFiles(workerJob, postProcess, blobContainer, dbContext, isDebugDump: false);
                    }
                    catch
                    {
                        // In case RScript execution fails, we still want to dump results into blob storage, so troubleshooting can be done later.
                        this.LogMessage(workerJob, "Crash while executing RScript processing. Uploading post-process dump.");
                        bool uploadedDump = false;
                        try
                        {
                            await this.ProcessGeneratedFiles(workerJob, postProcess, blobContainer, dbContext, isDebugDump: true);
                            uploadedDump = true;
                        }
                        catch
                        {
                            // If we failed uploading the dump we should continue.
                        }

                        if (uploadedDump)
                        {
                            this.LogMessage(workerJob, "Finished uploading post-process dump.");
                        }
                        else
                        {
                            this.LogMessage(workerJob, "Failed uploading post-process dump.");
                        }
                        
                        throw;
                    }
                }
            }
            finally
            {
                this.LogMessage(workerJob, "Deleting execution folder...");
                // Deletes the temp path
                try
                {
                    Directory.Delete(this.executionPath, true);
                }
                catch (IOException ex)
                {
                    // RDOTNET is not freeing the folder so this is common.
                }                

                this.LogMessage(workerJob, "Finished!...");
            }

            return true;
        }

        /// <summary>
        /// Generates the json parameters file.
        /// </summary>
        /// <param name="postProcess">The post process.</param>
        /// <param name="dbContext">The database context.</param>
        private async Task GenerateJsonParametersFile(DatasetPostProcess postProcess, RscriptModel rScriptModel, CustomSearchesDbContext dbContext)
        {
            List<CustomSearchExpression> rScriptParameters =
                (from e in dbContext.CustomSearchExpression
                 where e.DatasetPostProcessId == postProcess.DatasetPostProcessId
                 && (
                    (e.ExpressionRole.ToLower() == CustomSearchExpressionRoleType.RScriptParameter.ToString().ToLower()
                        && e.ExpressionType.ToLower() == CustomSearchExpressionType.RScript.ToString().ToLower()) ||
                    e.ExpressionRole.ToLower().StartsWith("CalculatedColumnPreCommit_".ToLower()))
                 orderby e.ExecutionOrder
                 select e).ToList();

            Dictionary<string, object> jsonParamters = new Dictionary<string, object>();

            var parameterNames = (from rsp in rScriptParameters
                                    select rsp.ColumnName).ToArray();

            parameterNames = ParameterReplacementHelper.MakeParameterNamesUnique(parameterNames);

            // Add RScript parameters from the DB
            for (int i = 0; i < parameterNames.Length; i++)
            {
                jsonParamters.Add(parameterNames[i], rScriptParameters[i].Script);
            }

            // Add user full name and email to parameters
            jsonParamters.Add("UserEmail", this.ServiceContext.AuthProvider.UserInfoData?.Email);
            jsonParamters.Add("UserFullName", this.ServiceContext.AuthProvider.UserInfoData?.FullName);

            // Add regression name
            jsonParamters.Add("RegressionName", rScriptModel.RscriptModelName);

            // Add valuation date
            UserProject project = await DatasetHelper.GetOwnerProjectAsync(postProcess.Dataset, dbContext);
            jsonParamters.Add("ValuationDate", ProjectVariableHelper.GetValuationDate(project));

            string jsonContents = JsonConvert.SerializeObject(jsonParamters, Formatting.Indented);
            this.trackedFiles.Add(RScriptProcessor.JsonParametersFileName.ToLower());

            string jsonParametersPath = Path.Combine(this.executionPath, RScriptProcessor.JsonParametersFileName);
            using (StreamWriter writer = File.CreateText(jsonParametersPath))
            {
                await writer.WriteAsync(jsonContents);
            }
        }

        /// <summary>
        /// Processes the generated files.
        /// </summary>
        /// <param name="workerJob">The worker job.</param>
        /// <param name="postProcess">The post process.</param>
        /// <param name="blobContainer">The BLOB container.</param>
        /// <param name="dbContext">The database context.</param>
        /// <param name="isDebugDump">if set to <c>true</c> indicates that this is a debug dump.</param>
        private async Task ProcessGeneratedFiles(
            WorkerJobQueue workerJob,
            DatasetPostProcess postProcess,
            CloudBlobContainer blobContainer,
            CustomSearchesDbContext dbContext,
            bool isDebugDump)
        {

            CloudBlobDirectory directory = blobContainer.GetDirectoryReference(
                $"{RScriptProcessor.BlobResultsFolderName}/{postProcess.DatasetId}/{postProcess.DatasetPostProcessId}".ToLower());

            await this.DeleteBlobDirectory(directory);

            bool jsonResultGenerated = false;

            string[] files = Directory.GetFiles(this.executionPath);
            foreach (var file in files)
            {
                string relativePath = Path.GetRelativePath(this.executionPath, file).ToLower();

                // If this is the Json results file, process it before uploading.
                if (relativePath == RScriptProcessor.JSonResultsFileName.ToLower() && !isDebugDump)
                {

                    await this.ProcessJSonResults(workerJob, relativePath);
                    jsonResultGenerated = true;
                }
                // If this is the csv file, process it before uploading.
                else if (relativePath == RScriptProcessor.OutputCsvFileName && !isDebugDump)
                {
                    await this.ProcessOutputCsv(postProcess, relativePath, dbContext);
                }

                // Upload if the file was not part of the initial set of files or if this is a debug dump.
                if (!this.trackedFiles.Contains(relativePath) || isDebugDump)
                {
                    var blobReference = directory.GetBlockBlobReference(relativePath);
                    await blobReference.UploadFromFileAsync(file);
                }
            }

            if (!jsonResultGenerated && !isDebugDump)
            {
                RScriptResultsData results = new RScriptResultsData()
                {
                    Status = "Success"
                };

                // Write results.
                string jsonResultPath = Path.Combine(this.executionPath, RScriptProcessor.JSonResultsFileName);
                string jsonResultString = JsonConvert.SerializeObject(results);
                workerJob.JobResult = jsonResultString;
                File.WriteAllText(jsonResultPath, jsonResultString);
            }
        }

        /// <summary>
        /// Deletes the content of the blob directory.
        /// </summary>
        /// <param name="directory">The BLOB directory.</param>
        private async Task DeleteBlobDirectory(CloudBlobDirectory directory)
        {
            bool folderIsEmpty = false;

            while (!folderIsEmpty)
            {
                var blobList = await directory.ListBlobsSegmentedAsync(currentToken: null);

                folderIsEmpty = true;

                foreach (IListBlobItem item in blobList.Results)
                {
                    folderIsEmpty = false;
                    await ((CloudBlockBlob)item).DeleteIfExistsAsync();
                }
            }
        }

        /// <summary>
        /// Processes the json results file.
        /// </summary>
        /// <param name="workerJob">The worker job.</param>
        /// <param name="path">The path.</param>
        /// <returns>The async task.</returns>
        private async Task ProcessJSonResults(WorkerJobQueue workerJob, string path)
        {
            // Load actual results.
            string jsonResultPath = Path.Combine(this.executionPath, path);
            string jsonResultString = await File.ReadAllTextAsync(jsonResultPath);
            RScriptResultsData results = JsonConvert.DeserializeObject<RScriptResultsData>(jsonResultString);

            results.Status = results.Status ?? "Success";

            // Rewrite results.
            jsonResultString = JsonConvert.SerializeObject(results);
            workerJob.JobResult = jsonResultString;
            await File.WriteAllTextAsync(jsonResultPath, jsonResultString);
        }

        /// <summary>
        /// Processes the output csv file.
        /// </summary>
        /// <param name="postProcess">The post process.</param>
        /// <param name="path">The path.</param>
        /// <param name="dbContext">The database context.</param>
        /// <returns>The async task.</returns>
        private async Task ProcessOutputCsv(DatasetPostProcess postProcess, string path, CustomSearchesDbContext dbContext)
        {
            // Load actual results.
            string outputPath = Path.Combine(this.executionPath, path);
            string jsonResultString = await File.ReadAllTextAsync(outputPath);

            string[] csvHeaders = null;
            int[] csvIndexKeys = null;
            List<string[]> csvRows = new List<string[]>();

            await CsvReader.ProcessCsvAsync(
                async (string[] headers, int[] indexKeys) =>
                {
                    csvHeaders = headers;
                    csvIndexKeys = indexKeys;
                    return true;
                },
                async (string[] fields) =>
                {
                    csvRows.Add(fields);
                },
                jsonResultString);

            await RScriptDatasetPostProcessExecutor.CreateRScriptPostProcessTableAsync(postProcess, csvHeaders, csvIndexKeys, csvRows, this.ServiceContext, dbContext);
        }

        /// <summary>
        /// Generates the dataset CSV file.
        /// </summary>
        /// <param name="dataset">The dataset.</param>
        /// <returns></returns>
        private async Task GenerateDatasetCsv(Dataset dataset, DatasetPostProcess rScriptPostProcess, WorkerJobQueue workerJob)
        {
            string csvPath = Path.Combine(this.executionPath, RScriptProcessor.DataCsvFileName);
            this.trackedFiles.Add(RScriptProcessor.DataCsvFileName.ToLower());
            using (StreamWriter writer = File.CreateText(csvPath))
            {
                var exportService = new ExportDatasetDataToFileService(this.ServiceContext);
                var processAction = new Func<GetUserCustomSearchDataResponse, int, ReadOnlyCollection<DbColumn>, Task>(
                    async (GetUserCustomSearchDataResponse datasetResponse, int i, ReadOnlyCollection<DbColumn> dbColumns) =>
                    {                    
                        await exportService.WriteCsvToStreamAsync(datasetResponse, i, writer);
                    });

                await exportService.ProcessDatasetAsync(
                    dataset,
                    processAction,
                    true,
                    rScriptPostProcess,
                    (string message) => { this.LogMessage(workerJob, message); });

                await writer.FlushAsync();
            }
        }

        /// <summary>
        /// Gets the r script file path.
        /// </summary>
        /// <param name="rScriptModel">The r script model.</param>
        /// <returns></returns>
        private string GetRScriptFilePath(RscriptModel rScriptModel)
        {
            return Path.Combine(this.executionPath, rScriptModel.RscriptFileName);
        }

        /// <summary>
        /// Executes the r script.
        /// </summary>
        /// <param name="rScriptModel">The r script model.</param>
        private async Task ExecuteRScript(RscriptModel rScriptModel)
        {
            string rScriptFilePath = this.GetRScriptFilePath(rScriptModel);
            string rScript = File.ReadAllText(rScriptFilePath);
            rScript = this.ReplaceParameters(rScript);
            int testSectionIndex = rScript.IndexOf(RScriptProcessor.TestSectionMarker);
            int serverSectionMarker = rScript.IndexOf(RScriptProcessor.ServerSectionMarker);
            if (testSectionIndex >= 0 && serverSectionMarker > testSectionIndex)
            {
                rScript = rScript.Substring(0, testSectionIndex) + rScript.Substring(serverSectionMarker);
            }

            string rExecutingFolder = this.executionPath.Replace("\\", "/");
            StringBuilder finalScriptBuilder = new StringBuilder();
            finalScriptBuilder.AppendLine("library(jsonlite)");
            finalScriptBuilder.AppendLine($"executingFolder <- \"{rExecutingFolder}\"");
            finalScriptBuilder.AppendLine($"parametersFileName <- \"{RScriptProcessor.JsonParametersFileName}\"");
            finalScriptBuilder.AppendLine($"datasetFileName <- \"{RScriptProcessor.DataCsvFileName}\"");
            finalScriptBuilder.AppendLine($"datasetSeparatorChar <- \"{ExportDatasetDataToFileService.CsvSeparator}\"");
            finalScriptBuilder.AppendLine("setwd(executingFolder)");
            finalScriptBuilder.AppendLine("paramJson <- fromJSON(parametersFileName)");
            finalScriptBuilder.AppendLine("dataset <- read.csv(file = datasetFileName, sep = datasetSeparatorChar)");
            finalScriptBuilder.AppendLine($"jsonResultFileName <- \"{RScriptProcessor.JSonResultsFileName}\"");            
            //finalScriptBuilder.AppendLine("dataset <- subset(dataset, dataset$Included.Or.Removed != \"Removed\")");
            
            finalScriptBuilder.AppendLine();
            finalScriptBuilder.Append(rScript);

            string finalScript = finalScriptBuilder.ToString();

            await semaphoreSlim.WaitAsync();
            try
            {
                RScriptHelper.Evaluate(finalScript);
            }
            finally
            {
                semaphoreSlim.Release();
            }
        }

        private string ReplaceParameters(string rScript)
        {
            return rScript.Replace("{LibrariesPath}", this.librariesPath);
        }

        /// <summary>
        /// Initializes the execution folder.
        /// </summary>
        /// <param name="dbContext">The database context.</param>
        /// <param name="blobContainer">The BLOB container.</param>
        /// <param name="payload">The worker job.</param>
        /// <param name="rScriptModelId">The r script model identifier.</param>
        /// <returns></returns>
        private async Task<RscriptModel> InitializeExecutionFolder(
            CustomSearchesDbContext dbContext,
            CloudBlobContainer blobContainer,
            WorkerJobQueue workerJob,
            RScriptJobPayload payload)
        {
            string jobExecutionPath = Path.Combine(this.executionPath, workerJob.JobId.ToString());

            Directory.CreateDirectory(this.executionPath);            
            RscriptModel rScriptModel = 
                await (from m in dbContext.RscriptModel join d in dbContext.DatasetPostProcess on m.RscriptModelId equals d.RscriptModelId 
                 where d.DatasetPostProcessId == payload.DatasetPostProcessId select m).FirstOrDefaultAsync();

            if (rScriptModel == null)
            {
                // TODO: throw exception.
            }

            CloudBlobDirectory directory = blobContainer.GetDirectoryReference(rScriptModel.RscriptFolderName);
            BlobContinuationToken continuationToken = null;
            BlobResultSegment results = await directory.ListBlobsSegmentedAsync(continuationToken);

            do
            {
                foreach (var blobItem in results.Results)
                {
                    string relativeBlobPath = blobItem.Uri.LocalPath.
                        Remove(0, RScriptProcessor.RScriptBlobContainerName.Length + 2);

                    var blobReference = blobContainer.GetBlobReference(relativeBlobPath);

                    string relativeLocalPath = relativeBlobPath.
                        Replace("/", "\\").
                        Remove(0, rScriptModel.RscriptFolderName.Length + 1);

                    this.trackedFiles.Add(relativeLocalPath.ToLower());
                    string downloadPath = Path.Combine(this.executionPath, relativeLocalPath);
                    await blobReference.DownloadToFileAsync(downloadPath, FileMode.CreateNew);
                }
            } while (results.ContinuationToken != null);


            // Checks that the r script file exists.
            string rScriptFilePath = this.GetRScriptFilePath(rScriptModel);
            if (!File.Exists(rScriptFilePath))
            {
                // Throw exception
            }

            return rScriptModel;
        }

        /// <summary>
        /// Gets the SignalR notification payload.
        /// </summary>
        /// <param name="workerJob">The worker job queue.</param>
        /// <returns>The payload.</returns>
        public override object GetSinalRNotificationPayload(WorkerJobQueue workerJob)
        {
            RScriptJobPayload payload = JsonConvert.DeserializeObject<RScriptJobPayload>(workerJob.JobPayload);
            return payload;
        }
    }
}
